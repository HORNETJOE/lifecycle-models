# lifecycle-models
### Table of content
#### 1.0 Waterfall (Sequential)
#### 2.0 Evolutionary (Iterative)
#### 3.0 Prototyping (Iterative)
#### 4.0 Spiral (Iterative)
#### 5.0 V model (Sequential)

### 1.0 Waterfall
   The waterfall Model is a linear sequential flow. In which progress is seen as flowing steadily downwards (like a waterfall) through the phases of software implementation. This means that any phase in the development process begins only if the previous phase is complete. The water fall model can be useful in a work environment because it can simulate the flow of work being completed and floating towards the goal of completing an objective or application.
    
   ### 1.1 Advantages
     
   - Simple and easy to understand and use

   - Easy to manage due to the rigidity of the model. Each phase has specific deliverables and a review process.

   - Phases are processed and completed one at a time.

   - Works well for smaller projects where requirements are very well understood.

   - Clearly defined stages.

   - Well understood milestones.

   - Easy to arrange tasks.

   - Process and results are well documented.
    
  ### 1.2 Disadvantage
     
   - No working software is produced until late during the life cycle.

   - High amounts of risk and uncertainty.

   - Not a good model for complex and object-oriented projects.

   - Poor model for long and ongoing projects.

   - Not suitable for the projects where requirements are at a moderate to high risk of changing. So, risk and uncertainty is high with        this process model.
   
   - It is difficult to measure progress within stages.

   - Cannot accommodate changing requirements.

   - Adjusting scope during the life cycle can end a project.

   - Integration is done as a "big-bang. at the very end, which doesn't allow identifying any technological or business bottleneck or      challenges early.
   
### 2.0 Evolutionary
The Evolutionary Model or approach is based on the idea of rapidly developing an initial software implementation from very abstract specifications and modifying this according to an appraisal. This type of model used in a workplace can help during development because it can show the growth of work show how functions in an application are changing and improving with each version.

### 2.1 Advantages
- Effective in rapidly producing small systems.

- Effective in software with short life spans.

- Effective in developing sub-components of larger systems.

### 2.2 Disadvantages
- It is difficult to measure progress and produce documentation reflecting every version of the system as it evolves.

-This paradigm usually results in badly structured programs due to continual code modification.

-Production of good quality software using this method requires highly skilled and motivated programmers.

### 3.0 Prototyping
   It refers to the activity of creating prototypes of software applications, for example, incomplete versions of the software program being developed. This can work well in a work environment because it can show how an application can grow and show which changes are being made between different version of the application. This allows the client or developers to jump back to earlier versions to make change without losing too much progress.
    
 ### 3.1 Advantages
    
   - Reduced time and costs, but this can be a disadvantage if the developer loses time in developing the prototypes.
    
   - Improved and increased user involvement.
    
 ### 3.2 Disadvantages
    
   - Insufficient analysisÂ· User confusion of prototype and finished system.
    
   - Developer misunderstanding of user objectives.
    
   - Excessive development time of the prototype.
    
   - Expense of implementing prototyping
    
### 4.0 Spiral
It is combining elements of both design and prototyping-in-stages, in an effort to combine advantages of top-down and bottom-up concepts. This model of development combines the features of the prototyping model and the waterfall model. The spiral model is favoured for large, expensive, and complicated projects. This model uses many of the same phases as the waterfall model, in essentially the same order, separated by planning, risk assessment, and the building of prototypes and simulations.

#### 4.1 how risk is managed in the Spiral lifecycle model
The spiral life-cycle is a risk driven model which means that this lifecycle model will be more successful and accurate the higher the risk analyses phase. The risk analyses phase is when the risks are weighed up with the project and see if the outcome is worth the risks. The spiral life-cycle is great at monitoring risks within a project and keeping up to date with them. This can create new opportunities to remove risks and keep note of risks in the future. the main importance of the Spiral Lifecycle is to reduce the amount and the effect these risks have on development and the application.

### 4.2 Advantages
- Estimates (i.e. budget, schedule, etc.) become more realistic as work progressed because important issues are discovered earlier.

- Early involvement of developers.

- Manages risks and develops the system into phases.

### 4.3 Disadvantages
- High cost and time to reach the final product.

- Needs special skills to evaluate the risks and assumptions.

- Highly customized limiting re-usability.

### 5.0 V model
The model process take place in a V shape during diagrams. The method of V model is to test each part of a development stage to ensure minimal errors and faults. This method takes place for every single phase of development. 

The V shape of the model is a presentation of when developing an application, it is better to work out words when developing new functions rather than working towards a final goal. This is better for development because the diagram suggests that if testing has failed for one of the function higher up the V model then the other function need to be tested to make sure that no errors have append during the development of further functions.

![Image](https://github.com/HORNETJOE/lifecycle-models/blob/master/v-model.png)

### 5.1 Advantages

-	This is a highly-disciplined model and Phases are completed one at a time.

-	Works well for smaller projects where requirements are very well understood.

-	Simple and easy to understand and use.

-	Easy to manage due to the rigidity of the model. Each phase has specific deliverables and a review process.

### 5.2 Disadvantages

-	High risk and uncertainty.

-	Not a good model for complex and object-oriented projects.

-	Poor model for long and ongoing projects.

-	Not suitable for the projects where requirements are at a moderate to high risk of changing.

-	Once an application is in the testing stage, it is difficult to go back and change a functionality.
